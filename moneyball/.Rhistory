X
Uniforme <- randomLHS(n=pontos, k=variaveis)
plot(Y[,3])
plot(Y[,3],Y[,2])
plot(Y[,3],Y[,2])
library("lhs")
variaveis = 3
pontos = 1000
# Obtendo números aleatórios com LHS
X <- randomLHS(pontos, variaveis)
# Transformando o Hypercubo em variáveis
Y <- matrix(0, nrow=1000, ncol=3)
# Primeira variável é normal com média 3 e desv. pad. 0.1
Y[,1] <- qnorm(X[,1], mean=3, sd=0.1)
# Segunda Variável é beta, com média 2
Y[,2] <- qbeta(X[,2], shape1=2, shape2=3)
# Terceira Variável é uniforme, entre 10 e 100
Y[,3] = qunif(p=X[,3],min=10, max=100)
plot(Y[,3],Y[,2])
library("lhs")
variaveis = 3
pontos = 1000
# Obtendo números aleatórios com LHS
X <- randomLHS(pontos, variaveis)
# Transformando o Hypercubo em variáveis
Y <- matrix(0, nrow=1000, ncol=3)
# Primeira variável é normal com média 3 e desv. pad. 0.1
Y[,1] <- qnorm(X[,1], mean=3, sd=0.1)
# Segunda Variável é beta, com média 2
Y[,2] <- qbeta(X[,2], shape1=2, shape2=3)
# Terceira Variável é uniforme, entre 10 e 100
Y[,3] = qunif(p=X[,3],min=10, max=100)
plot(Y[,3],Y[,2])
library("lhs")
variaveis = 3
pontos = 1000
# Obtendo números aleatórios com LHS
X <- randomLHS(pontos, variaveis)
# Transformando o Hypercubo em variáveis
Y <- matrix(0, nrow=1000, ncol=3)
# Primeira variável é normal com média 3 e desv. pad. 0.1
Y[,1] <- qnorm(X[,1], mean=3, sd=0.1)
# Segunda Variável é beta, com média 2
Y[,2] <- qbeta(X[,2], shape1=2, shape2=3)
# Terceira Variável é uniforme, entre 10 e 100
Y[,3] = qunif(p=X[,3],min=10, max=100)
plot(Y[,3],Y[,2])
library("lhs")
variaveis = 3
pontos = 1000
# Obtendo números aleatórios com LHS
X <- randomLHS(pontos, variaveis)
# Transformando o Hypercubo em variáveis
Y <- matrix(0, nrow=1000, ncol=3)
# Primeira variável é normal com média 3 e desv. pad. 0.1
Y[,1] <- qnorm(X[,1], mean=3, sd=0.1)
# Segunda Variável é beta, com média 2
Y[,2] <- qbeta(X[,2], shape1=2, shape2=3)
# Terceira Variável é uniforme, entre 10 e 100
Y[,3] = qunif(p=X[,3],min=10, max=100)
plot(Y[,3],Y[,2])
library("lhs")
variaveis = 3
pontos = 1000
# Obtendo números aleatórios com LHS
X <- randomLHS(pontos, variaveis)
# Transformando o Hypercubo em variáveis
Y <- matrix(0, nrow=1000, ncol=3)
# Primeira variável é normal com média 3 e desv. pad. 0.1
Y[,1] <- qnorm(X[,1], mean=3, sd=0.1)
# Segunda Variável é beta, com média 2
Y[,2] <- qbeta(X[,2], shape1=2, shape2=3)
# Terceira Variável é uniforme, entre 10 e 100
Y[,3] = qunif(p=X[,3],min=10, max=100)
plot(Y[,3],Y[,2])
library("lhs")
variaveis = 3
pontos = 1000
# Obtendo números aleatórios com LHS
X <- randomLHS(pontos, variaveis)
# Transformando o Hypercubo em variáveis
Y <- matrix(0, nrow=1000, ncol=3)
# Primeira variável é normal com média 3 e desv. pad. 0.1
Y[,1] <- qnorm(X[,1], mean=3, sd=0.1)
# Segunda Variável é beta, com média 2
Y[,2] <- qbeta(X[,2], shape1=2, shape2=3)
# Terceira Variável é uniforme, entre 10 e 100
Y[,3] = qunif(p=X[,3],min=10, max=100)
plot(Y[,3],Y[,2])
library("lhs")
variaveis = 3
pontos = 1000
# Obtendo números aleatórios com LHS
X <- randomLHS(pontos, variaveis)
# Transformando o Hypercubo em variáveis
Y <- matrix(0, nrow=1000, ncol=3)
# Primeira variável é normal com média 3 e desv. pad. 0.1
Y[,1] <- qnorm(X[,1], mean=3, sd=0.1)
# Segunda Variável é beta, com média 2
Y[,2] <- qbeta(X[,2], shape1=2, shape2=3)
# Terceira Variável é uniforme, entre 10 e 100
Y[,3] = qunif(p=X[,3],min=10, max=100)
plot(Y[,3],Y[,2])
library("lhs")
variaveis = 3
pontos = 1000
# Obtendo números aleatórios com LHS
X <- randomLHS(pontos, variaveis)
# Transformando o Hypercubo em variáveis
Y <- matrix(0, nrow=1000, ncol=3)
# Primeira variável é normal com média 3 e desv. pad. 0.1
Y[,1] <- qnorm(X[,1], mean=3, sd=0.1)
# Segunda Variável é beta, com média 2
Y[,2] <- qbeta(X[,2], shape1=2, shape2=3)
# Terceira Variável é uniforme, entre 10 e 100
Y[,3] = qunif(p=X[,3],min=10, max=100)
plot(Y[,3],Y[,2])
library("lhs")
variaveis = 3
pontos = 1000
# Obtendo números aleatórios com LHS
X <- randomLHS(pontos, variaveis)
# Transformando o Hypercubo em variáveis
Y <- matrix(0, nrow=1000, ncol=3)
# Primeira variável é normal com média 3 e desv. pad. 0.1
Y[,1] <- qnorm(X[,1], mean=3, sd=0.1)
# Segunda Variável é beta, com média 2
Y[,2] <- qbeta(X[,2], shape1=2, shape2=3)
# Terceira Variável é uniforme, entre 10 e 100
Y[,3] = qunif(p=X[,3],min=10, max=100)
plot(Y[,3],Y[,2])
library("lhs")
variaveis = 3
pontos = 1000
# Obtendo números aleatórios com LHS
X <- randomLHS(pontos, variaveis)
# Transformando o Hypercubo em variáveis
Y <- matrix(0, nrow=1000, ncol=3)
# Primeira variável é normal com média 3 e desv. pad. 0.1
Y[,1] <- qnorm(X[,1], mean=3, sd=0.1)
# Segunda Variável é beta, com média 2
Y[,2] <- qbeta(X[,2], shape1=2, shape2=3)
# Terceira Variável é uniforme, entre 10 e 100
Y[,3] = qunif(p=X[,3],min=10, max=100)
plot(Y[,3],Y[,2])
library("lhs")
variaveis = 3
pontos = 1000
# Obtendo números aleatórios com LHS
X <- randomLHS(pontos, variaveis)
# Transformando o Hypercubo em variáveis
Y <- matrix(0, nrow=1000, ncol=3)
# Primeira variável é normal com média 3 e desv. pad. 0.1
Y[,1] <- qnorm(X[,1], mean=3, sd=0.1)
# Segunda Variável é beta, com média 2
Y[,2] <- qbeta(X[,2], shape1=2, shape2=3)
# Terceira Variável é uniforme, entre 10 e 100
Y[,3] = qunif(p=X[,3],min=10, max=100)
plot(Y[,3],Y[,2])
library("lhs")
variaveis = 3
pontos = 1000
# Obtendo números aleatórios com LHS
X <- randomLHS(pontos, variaveis)
# Transformando o Hypercubo em variáveis
Y <- matrix(0, nrow=1000, ncol=3)
# Primeira variável é normal com média 3 e desv. pad. 0.1
Y[,1] <- qnorm(X[,1], mean=3, sd=0.1)
# Segunda Variável é beta, com média 2
Y[,2] <- qbeta(X[,2], shape1=2, shape2=3)
# Terceira Variável é uniforme, entre 10 e 100
Y[,3] = qunif(p=X[,3],min=10, max=100)
plot(Y[,3],Y[,2])
library("lhs")
variaveis = 3
pontos = 1000
# Obtendo números aleatórios com LHS
X <- randomLHS(pontos, variaveis)
# Transformando o Hypercubo em variáveis
Y <- matrix(0, nrow=1000, ncol=3)
# Primeira variável é normal com média 3 e desv. pad. 0.1
Y[,1] <- qnorm(X[,1], mean=3, sd=0.1)
# Segunda Variável é beta, com média 2
Y[,2] <- qbeta(X[,2], shape1=2, shape2=3)
# Terceira Variável é uniforme, entre 10 e 100
Y[,3] = qunif(p=X[,3],min=10, max=100)
plot(Y[,3],Y[,2])
library("lhs")
variaveis = 3
pontos = 1000
# Obtendo números aleatórios com LHS
X <- randomLHS(pontos, variaveis)
# Transformando o Hypercubo em variáveis
Y <- matrix(0, nrow=1000, ncol=3)
# Primeira variável é normal com média 3 e desv. pad. 0.1
Y[,1] <- qnorm(X[,1], mean=3, sd=0.1)
# Segunda Variável é beta, com média 2
Y[,2] <- qbeta(X[,2], shape1=2, shape2=3)
# Terceira Variável é uniforme, entre 10 e 100
Y[,3] = qunif(p=X[,3],min=10, max=100)
plot(Y[,3],Y[,2])
plot(X[,3],X[,2])
plot(Y[,3],Y[,2])
# Observando as Variáveis Das Distribuições
plot(Y[,3],Y[,2])
plot(X[,3],X[,2])
plot(X[,3],X[,2])
plot(X[,3],X[,2])
# Observando as Variáveis Das Distribuições
plot(Y[,3],Y[,2])
plot(X[,3],X[,2])
variaveis = 3
pontos = 10
# Obtendo números aleatórios com LHS
X <- randomLHS(pontos, variaveis)
# Transformando o Hypercubo em variáveis
Y <- matrix(0, nrow=1000, ncol=3)
# Primeira variável é normal com média 3 e desv. pad. 0.1
Y[,1] <- qnorm(X[,1], mean=3, sd=0.1)
# Segunda Variável é beta, com média 2
Y[,2] <- qbeta(X[,2], shape1=2, shape2=3)
# Terceira Variável é uniforme, entre 10 e 100
Y[,3] = qunif(p=X[,3],min=10, max=100)
plot(X[,3],X[,2])
plot(Y[,3],Y[,2])
plot(Y[,3],Y[,2])
plot(X[,3],X[,2])
plot(Y[,3],Y[,2])
plot(X[,3],X[,2])
plot(Y[,3],Y[,2])
library("lhs")
variaveis = 3
pontos = 2000
# Obtendo números aleatórios com LHS
X <- randomLHS(pontos, variaveis)
# Transformando o Hypercubo em variáveis
Y <- matrix(0, nrow=1000, ncol=3)
# Primeira variável é normal com média 3 e desv. pad. 0.1
Y[,1] <- qnorm(X[,1], mean=3, sd=0.1)
# Segunda Variável é beta, com média 2
Y[,2] <- qbeta(X[,2], shape1=2, shape2=3)
# Terceira Variável é uniforme, entre 10 e 100
Y[,3] = qunif(p=X[,3],min=10, max=100)
#Observando as Variáveis Do Hypercubo:
plot(X[,3],X[,2])
# Observando as Variáveis Das Distribuições
plot(Y[,3],Y[,2])
plot(Y[,3],Y[,2])
library("lhs")
variaveis = 3
pontos = 2000
# Obtendo números aleatórios com LHS
X <- randomLHS(pontos, variaveis)
# Transformando o Hypercubo em variáveis
Y <- matrix(0, nrow=pontos, ncol=variaveis)
# Primeira variável é normal com média 3 e desv. pad. 0.1
Y[,1] <- qnorm(X[,1], mean=3, sd=0.1)
# Segunda Variável é beta, com média 2
Y[,2] <- qbeta(X[,2], shape1=2, shape2=3)
# Terceira Variável é uniforme, entre 10 e 100
Y[,3] = qunif(p=X[,3],min=10, max=100)
#Observando as Variáveis Do Hypercubo:
plot(X[,3],X[,2])
# Observando as Variáveis Das Distribuições
plot(Y[,3],Y[,2])
plot(X[,3],X[,2])
plot(Y[,3],Y[,2])
plot(X[,3],X[,2])
plot(Y[,3],Y[,2])
plot(X[,3],X[,2])
plot(Y[,3],Y[,2])
plot(X[,3],X[,2])
matriz = matrix(NA,nrow=10,ncol=3,dimnames = c("A","B","C"))
matriz
matriz = matrix(NA,nrow=10,ncol=3,dimnames = c("A","B","C"))
matriz
lista = list(c("A"))
lista
lista = list(c("A","B","C"))
lista
lista
matriz = matrix(NA,nrow=10,ncol=3,dimnames = lista)
lista = list("Teste",c("A","B","C"))
lista
lista = list("Teste",c("A","B","C"))
lista
matriz = matrix(NA,nrow=10,ncol=3,dimnames = lista)
lista = list("Teste",c("A","B"))
lista
lista
matriz = matrix(NA,nrow=10,ncol=3,dimnames = lista)
lista = list("Teste",c("A","B"))
lista
lista
matriz = matrix(NA,nrow=10,ncol=3,dimnames = lista)
lista = list("Teste",c("A","B"))
lista
lista
matriz = matrix(NA,nrow=10,ncol=3,dimnames = lista)
lista = list("Teste",c("A","B"))
lista
lista
matriz = matrix(NA,nrow=10,ncol=3,dimnames = lista)
lista = list(c("A","B"))
lista
lista
matriz = matrix(NA,nrow=10,ncol=3,dimnames = lista)
lista = list(c("A","B"))
lista
lista
matriz = matrix(NA,nrow=10,ncol=3,dimnames = lista)
lista = list(c("A","B"))
lista
lista
matriz = matrix(NA,nrow=10,ncol=3,dimnames = lista)
#' Criando Vetores com valores simples
#' ========================================================
numeric_vector <- c(1, 10, 49)
character_vector <- c("a", "b", "c")
#' c() = Combine Function - Cria um vetor!
#' ========================================================
# Complete the code for boolean_vector
boolean_vector <- c(TRUE, FALSE, TRUE)
#' Montando Vetores
#' ========================================================
# Poker winnings from Monday to Friday
poker_vector <- c(140, -50, 20, -120, 240)
# Roulette winnings from Monday to Friday
roulette_vector <-  c(-24, -50, 100, 350, 10)
poker_vector
#' Nomeando as Variáveis de um Vetor
#' ========================================================
# Poker winnings from Monday to Friday
poker_vector <- c(140, -50, 20, -120, 240)
# Roulette winnings from Monday to Friday
roulette_vector <- c(-24, -50, 100, -350, 10)
#' Criando Vetores com valores simples
#' ========================================================
numeric_vector <- c(1, 10, 49)
character_vector <- c("a", "b", "c")
#' c() = Combine Function - Cria um vetor!
#' ========================================================
# Complete the code for boolean_vector
boolean_vector <- c(TRUE, FALSE, TRUE)
#' Montando Vetores
#' ========================================================
# Poker winnings from Monday to Friday
poker_vector <- c(140, -50, 20, -120, 240)
# Roulette winnings from Monday to Friday
roulette_vector <-  c(-24, -50, 100, 350, 10)
poker_vector
#' Nomeando as Variáveis de um Vetor
#' ========================================================
# Poker winnings from Monday to Friday
poker_vector <- c(140, -50, 20, -120, 240)
# Roulette winnings from Monday to Friday
roulette_vector <- c(-24, -50, 100, -350, 10)
days_vector <- c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday")
names(poker_vector) <-   days_vector
names(roulette_vector) <- days_vector
dia = "Monday"
roulette_vector[dia]
roullete_vector
roulette_vector
roulette_vector
# Take the sum of A_vector and B_vector
total_vector <- B_vector + A_vector
#' Somando Vetores
A_vector <- c(1, 2, 3)
B_vector <- c(4, 5, 6)
# Take the sum of A_vector and B_vector
total_vector <- B_vector + A_vector
total_vector
total_poker <- sum(poker_vector)
total_roulette <-  sum(roulette_vector)
sum(poker_vector)
sum(poker_vector)
sum(poker_vector)
poker_vector[c(2,3,4)]
poker_vector[2:4]
poker_vector[c("Monday", "Tuesday", "Wednesday")]
poker_vector[c("Monday", "Tuesday", "Wednesday")]
poker_vector[c("Monday", "Tuesday", "Wednesday")]
poker_vector[c("Monday", "Tuesday", "Wednesday")]
poker_vector[c("Monday", "Tuesday", "Wednesday")]
poker_vector[c("Monday", "Tuesday", "Wednesday")]
poker_vector[c("Monday", "Tuesday", "Wednesday")]
years_vector = seq(from=initial_year, to=initial_year+n-1, by=1)
years_vector = 10:20
years_vector
library(fitdistrplus)
# Carregando arquivos com Funções
source("financial_functions.R")
source("cba.R")
source("data_import.R")
### TODO: Importar aqui
dados = import_data("Dados.xlsx")
## Primeiro teste para rodar uma análise de custo benefício probabilística
### Parâmetros para Rodar a Análise
#Número de Períodos a Analisar e Ano Inicial
n = 10
initial_year = 2017
### Rodando a Análise CBA 200 vezes
cba_replications = replicate(n=100,
cba_analysis(mean_cost=30,
sd_cost=5,
mean_benefit=30,
sd_benefit=10)
)
# Separando os resultados em vetores diferentes
# vendo o VPL
vpl = cba_replications[1,]
# retornando o CBR
cbr = cba_replications[2,]
# retornando o ROI
roi = cba_replications[3,]
# Ajustando o Gráfico para 3 imagens:
par(mfrow=c(1,3))
# Vendo a Distribuição do VPL
hist(vpl,main="Distribuição do VPL")
# Vendo a Distribuição do CBR
hist(cbr,main="Distribuição do CBR")
# Vendo a Distribuição do ROI
hist(roi,main="Distribuição do ROI")
# Ajustando o CBA para uma distribuição normal
cbr_fit = fitdist(cbr,"norm")
roi_fit = fitdist(roi,"norm")
vpl_fit = fitdist(vpl,"norm")
# Estimando o CBR
cbr_medio = as.numeric(cbr_fit$estimate[["mean"]])
cbr_medio = round(cbr_medio, digits=2)
cat("Para cada 1 real investido em SST, retornam em média ", cbr_medio, " Reais.")
# Estimando o ROI
roi_medio = as.numeric(roi_fit$estimate[["mean"]])*100
roi_medio = round(roi_medio,digits = 2)
cat("O retorno sobre investimento esperado é de ", roi_medio, " %.")
# Informando o VPL
vpl_medio = as.numeric(vpl_fit$estimate[["mean"]])
vpl_medio = round(vpl_medio,digits = 2)
cat("O Valor Presente Líquido do Investimento esperado é ", vpl_medio, " Reais.")
# # Mostrando o Intervalo de Confiança do CBR..
# confint(cba_fit)
#
# # Ajustando o gráfico...
# par(mfrow=c(2,2))
# # Mostrando os resultados do Ajuste à distribuição Normal
# plot(cba_fit)
# Carregando arquivos com Funções
source("financial_functions.R")
source("cba.R")
source("data_import.R")
install.packages('rsconnect')
rsconnect::setAccountInfo(name='pedrolima',
token='D6182C94E4F7C6CCF5ED7636EFF17A07',
secret='d3wRSO1Lu/86HIjIjyvLuCT9JNIMJ3GP8X9gX1iC')
install.packages("shiny")
summary(baseball)
#' Exemplo - MoneyBall
#' ========================================================
#' Este exemplo usa dados relacionados ao filme "Moneyball" para apresentar a técnica de regressão linear com o R.
#' Este exercício é baseado em uma aula do MIT, na plataforma Edx: https://courses.edx.org/courses/course-v1:MITx+15.071x_3+1T2016/
#'
#' Lendo Dados em CSV
#' ========================================================
#' Normalmente lemos dados no formato .csv no R para realizar as análises. É possível também ler dados em outros formatos.
# Definindo o Working Directory (pasta base na qual estaremos trabalhando)
setwd("D:/DADOS/dev/sigepro-moneyball/moneyball")
# Lendo Dados em CSV
baseball = read.csv("baseball.csv")
#' Conhecendo os Dados
#' ========================================================
#' Antes de rodar qualquer análise precisamos conhecer a estrutura dos dados.
# Podemos fazer isso usando a função str() (que mostra a estrutura)
str(baseball)
# Ou também podemos ver um resumo dos dados
summary(baseball)
baseball$Year
hist(baseball$Year)
ktable(baseball)
library("knitr")
str(baseball)
est = str(baseball)
str(baseball)
library(knitr)
source('D:/dev/sigepro-intro-R/moneyball/sigepro_moneyball.R')
knitr::spin()
knitr::spin(hair = "/.sigepro_moneyball.R")
knitr::spin(hair = "D:/dev/sigepro-intro-R/sigepro_moneyball.R")
knitr::spin(hair = "D:/dev/sigepro-intro-R/moneyball/sigepro_moneyball.R")
knitr::spin(hair = "D:/dev/sigepro-intro-R/moneyball/sigepro_moneyball.R", knit = TRUE)
knitr::spin(hair = "D:/dev/sigepro-intro-R/moneyball/sigepro_moneyball.R", knit = TRUE)
str(baseball)
# Podemos fazer isso usando a função str() (que mostra a estrutura)
str(baseball)
baseball
moneyball$RS
moneyball$RA
predict(modelo_vitorias, 80)
modelo_vitorias = lm(W ~ RD, data=moneyball)
predict(modelo_vitorias, RD = 80)
devtools::install_github("kassambara/ggpubr")
install.packages("ggpubr")
RD_min = (95 - 80.8814)/0.1058
RD_min
modeloruns_sBA = lm(formula = RS ~ OBP + SLG, data=moneyball)
summary(modeloruns_sBA)
modelorunsallowed = lm(formula = RA ~ OOBP + OSLG, data=moneyball)
summary(modelorunsallowed)
Runs = -804.3 + 2737.77 * 0.339 + 1584.91 *  0.430
Runs
Vitorias = 80.88 + 0.1057 * (Runs - RunsAllowed)
Vitorias
